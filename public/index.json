
[{"content":"","date":"3 December 2025","externalUrl":null,"permalink":"/","section":"Connor Bryan","summary":"","title":"Connor Bryan","type":"page"},{"content":" Recently, I\u0026rsquo;ve been researching quantum mechanics, especially around quantum computing and I\u0026rsquo;ve been following a textbook on quantum machine learning. After using Python libraries like Cirq for the creation of circuits, I had the thought of creating a library in a language I enjoy using like Rust. The goal of the first draft of the simulator was to create a simple Bell state circuit. This project has a bunch of parts;\nA representation of complex numbers The quantum state representation that will be updated throughout the circuit A circuit struct to hold all the gates in order that will be applied to the state A simulator that will apply those gates step by step to the state and return the result To top this all off, I decided to add a further restriction of using as few external libraries as possible.\nQubit representation # In its most basic form, a quantum computer measures the change of the state of a quantum bit over the evolution of the circuit. In classical computing a bit is the most fundamental unit of information and is represented as a \u0026ldquo;1\u0026rdquo; or \u0026ldquo;0\u0026rdquo;. The quantum counterpart of this classical unit is a quantum bit, or qubit, which can be represented in the same way as the classical bit but with the added dimension of superposition where it can be both a \u0026ldquo;1\u0026rdquo; and \u0026ldquo;0\u0026rdquo; at the same time.\nIn quantum mechanics the states corresponding to \u0026ldquo;1\u0026rdquo; and \u0026ldquo;0\u0026rdquo; are two-dimensional state vectors $\\vec{0}$ and $\\vec{1}$ where $\\vec{0} = \\begin{bmatrix}1\\\\0\\end{bmatrix}$ and $\\vec{1} = \\begin{bmatrix}0\\\\1\\end{bmatrix}$. A superposition of the states is represented as the linear combination of these two states being $\\ket{\\psi} = \\alpha\\ket{0} + \\beta\\ket{1}$. This may look complicated however lets imagine those two state vectors represent directions on a 2D graph where, $\\ket{0}$ is the X axis and $\\ket{1}$ is the Y axis. The overall state is the direction in which the sum of the two vectors is. Lets say we have a value of 0.5 in the x axis and 0.5 in the y axis, imagine travelling 0.5 units in the x axis and then the y axis, now from that position return to the origin and we have found the sum of these two vectors, now the ratio between the angle of that sum and the axis is the probability of the qubit being in state 0 or 1 which in this case is 50/50. If we travelled 1 unit in the X axis and 0 in the Y axis the state would be 0 with 100% probability. If we extend this idea to include a Z axis we would end up with the Bloch sphere representation of the qubit.\nSo as we have just seen we can represent a qubit as a complex number, this means to start coding this simulator in rust we need a struct for a complex number to represent each qubit. This is quite easy as we can create a struct called Complex and have two properties of real and imaginary to represent the number. We store the values as f64 as a 64-bit floating point number as the multiplier is usually a fraction such as $\\frac{1}{\\sqrt{2}}$ as we will see a bit later.\n/// Complex number representation, these are the representation /// of Qubits within the circuit. #[derive(Debug, Clone, Copy, PartialEq)] pub struct Complex { /// Real part to the number pub real: f64, /// Imaginary part of the number pub imag: f64, } Our complex number struct needs to do more than just hold the values of the qubit, we also need to do math on it. As such we implement the following functions;\nWe need a constructor for the struct which we call new and this takes in the real and imaginary part of the number. The add function calculates the sum between two complex numbers and returns a third. The subtract function does the opposite of the add function. The multiply function calculates the product between two complex numbers. The scale function multiplies the complex number by a scalar. The magnitude squared function is possibly the most important one and is used to calculate the probability of the qubit in the state vector. The conjugate function is used to calculate the complex conjugate of the qubit and is used in certain gates as a flip operator. Finally the exp calculates the complex exponential of the complex number and is used in the quantum Fourier transform circuit. impl Complex { /// Creates a new complex number with the specified real and /// imaginary counterparts. pub fn new(real: f64, imag: f64) -\u0026gt; Self { ... } /// Addition operation between two complex numbers. /// num1 = a + bi /// num2 = c + di /// result = (a + c) + (b + d)i pub fn add(\u0026amp;self, other: \u0026amp;Complex) -\u0026gt; Complex { ... } /// Subtraction operation between two complex numbers. /// num1 = a + bi /// num2 = c + di /// result = (a - c) + (b - d)i pub fn subtract(\u0026amp;self, other: \u0026amp;Complex) -\u0026gt; Complex { ... } /// Multiplication operation between two complex numbers. /// num1 = a + bi /// num2 = c + di /// result = (ac - bd) + (ad + bc)i pub fn multiply(\u0026amp;self, other: \u0026amp;Complex) -\u0026gt; Complex { ... } /// Scale the complex number by a scalar value. /// num1 = a + bi /// scalar = x /// result = (x * a) + (x * b)i pub fn scale(\u0026amp;self, scalar: f64) -\u0026gt; Complex { ... } /// Calculate the magnitude squared of the complex number. /// Used to get the probability of the quantum state vector. /// num1 = a + bi /// result = |a|^2 + (|b|^2)i pub fn magnitude_squared(\u0026amp;self) -\u0026gt; f64 { ... } /// Calculate the complex conjugate (flip the sign on the imaginary part) /// num1 = a + bi /// result = a - bi pub fn conjugate(\u0026amp;self) -\u0026gt; Complex { ... } /// Compute the complex exponential e^(a+bi) /// Using Euler\u0026#39;s formula: e^(a+bi) = e^a * (cos(b) + i*sin(b)) pub fn exp(\u0026amp;self) -\u0026gt; Complex { ... } } Im leaving out some of the internals of the functions from brevity of this blog post, however if your interested, the link to the GitHub project will be at the bottom.\nQuantum State # The quantum state vector stores all possible outcomes for an n-qubit system. For a 2-qubit system, when we perform a measurement and collapse the wave function, we could end up with one of 4 states: \u0026ldquo;00\u0026rdquo;, \u0026ldquo;01\u0026rdquo;, \u0026ldquo;10\u0026rdquo; or \u0026ldquo;11\u0026rdquo;. During the circuit when qubits are in superposition, we don\u0026rsquo;t know what the measurement will yield. Each basis state has a corresponding complex amplitude stored in the state vector. The probability of measuring each state is calculated as the magnitude squared of its amplitude. The simulator uses this state vector to track how the quantum system transforms as gates are applied throughout the circuit.\n// The Quantum State Vector that holds the state of the system for 2^n qubits #[derive(Clone)] pub struct QuantumState { pub amplitudes: Vec\u0026lt;Complex\u0026gt;, pub num_qubits: usize, } In this simulator we need a quantum state vector to hold the state of the system which will be transformed over the length of the circuit. For this struct we need the number of qubits in the system (used to calculate the length of the state vector), and the amplitudes of the system which is a vector of complex numbers.\nDuring the new function we initialise the system to have n qubits all in the state |0⟩. Specifically, we create a state vector of length 2^n, where the first amplitude is set to 1+0i (representing the |00\u0026hellip;0⟩ state) and all other amplitudes are set to 0+0i. This function then returns the fresh state vector. We have a function called normalize to ensure the sum of all |amplitude|² equals 1. This maintains the fundamental requirement that all measurement probabilities must sum to 1. After certain operations (or due to floating-point errors), the state may need renormalization. The measure function implements probabilistic measurement. It calculates the probability for each basis state using |amplitude|², then picks a random value by choosing a random number between 0-1 and iterating over every state, accumulating their probabilities until the cumulative sum exceeds the generated random number. The basis state whose probability pushed the cumulative sum over the random number is the chosen \u0026ldquo;winner\u0026rdquo; which becomes the measurement outcome. impl QuantumState { /// Create state with n qubits, all in |0⟩ pub fn new(num_qubits: usize) -\u0026gt; QuantumState { let size = 2_usize.pow(num_qubits as u32); let mut amplitudes = Vec::new(); for i in 0..size { if i == 0 { amplitudes.push(Complex::new(1.0, 0.0)); } else { amplitudes.push(Complex::new(0.0, 0.0)); } } QuantumState { amplitudes, num_qubits } } /// Ensure sum of all amplitudes in the Quantum State equal 1, |amplitude|² = 1 pub fn normalize(\u0026amp;mut self) { let mut sum = 0.0; // Calculate sum of |amplitude|² for amplitude in \u0026amp;self.amplitudes { sum += amplitude.magnitude_squared() } // Handle edge case if sum == 0.0 { return; // Can\u0026#39;t normalize zero vector } let norm = f64::sqrt(sum); // Scale each amplitude for amplitude in \u0026amp;mut self.amplitudes { *amplitude = amplitude.scale(1.0 / norm); } } /// Measure all qubits, return bitstring (e.g., \u0026#34;01\u0026#34; for 2 qubits) pub fn measure(\u0026amp;self) -\u0026gt; String { let mut rng = rand::rng(); let r: f64 = rng.random(); let mut cumulative = 0.0; let mut chosen_index = 0; // Loop through amplitudes and find which index to measure for (index, amplitude) in self.amplitudes.iter().enumerate() { cumulative += amplitude.magnitude_squared(); if r \u0026lt; cumulative { chosen_index = index; break; } } format!(\u0026#34;{:0width$b}\u0026#34;, chosen_index, width = self.num_qubits) } } Required Gates # As a basic test for this circuit we want to create a bell state circuit. The bell state is a simple circuit to create entanglement between two qubits. Entanglement makes it so the two qubits are correlated - a measurement of one qubit will give you information about the other\u0026rsquo;s state. Specifically, in this Bell state, if you measure the first qubit and get |0⟩, the second qubit will also be |0⟩; if you get |1⟩, the second will also be |1⟩. The Bell state is represented by $\\ket{\\psi} = \\frac{1}{\\sqrt{2}}\\ket{00} + \\frac{1}{\\sqrt{2}}\\ket{11}$. This circuit is simple (in quantum mechanical terms) and only requires two gates; the Hadamard gate to create a superposition in one of the qubits, and the controlled NOT gate to entangle the second qubit with the first one.\nIn our circuit we treat gates as a queue of operations that are executed by the simulator, like a queue of people at a fast food restaurant. The gates are stored as a vector on enums where each enum variant has its own corresponding function. The enum variants are initialised with the information required for their function, for example, the Hadamard variant stores the target qubit index.\n/// Quantum gates supported by the simulator. /// /// All gates are represented with their target qubit index (0-indexed). /// Multi-qubit gates like CNOT also specify control qubits. #[derive(Debug, Clone, Copy)] pub enum Gate { /// Hadamard gate - creates superposition /// Transforms |0⟩ → (1/√2)(|0⟩ + |1⟩) and |1⟩ → (1/√2)(|0⟩ - |1⟩) Hadamard { target: usize }, /// Controlled-NOT gate - flips target if control is |1⟩ CNOT { control: usize, target: usize }, } The Hadamard gate implementation takes the quantum state and the target qubit index as inputs. The algorithm works by identifying and transforming pairs of amplitudes in the state vector. We loop through all amplitude indices. For each index i, we use a bitwise mask (i \u0026amp; (1 \u0026lt;\u0026lt; target_qubit)) == 0 to check if the bit at position target_qubit is 0. If it is, we pair this index with j = i + 2^target_qubit, which represents the same basis state but with the target qubit flipped to 1.\nWhen applying a single-qubit gate in a multi-qubit system, we only transform amplitudes for basis states that differ in the target qubit. For example, applying Hadamard to qubit 0 in a 2-qubit system means we process pairs like (|00⟩, |01⟩) and (|10⟩, |11⟩) - states that differ only in qubit 0\u0026rsquo;s value. For each pair of amplitudes {$\\alpha$, $\\beta$}, we apply the Hadamard matrix:\nStore the current values of both amplitudes Calculate new values: $\\alpha' = (1/\\sqrt{2})(\\alpha + \\beta)$ and $\\beta' = (1/\\sqrt{2})(\\alpha - \\beta)$ Update both amplitudes in the state vector By only processing indices where the target bit is 0, we ensure each pair is processed exactly once, avoiding redundant calculations.\n/// Applies a Hadamard gate to the specified qubit. /// /// The Hadamard gate creates superposition, transforming: /// - |0⟩ → (1/√2)(|0⟩ + |1⟩) /// - |1⟩ → (1/√2)(|0⟩ - |1⟩) pub fn apply_hadamard(state: \u0026amp;mut QuantumState, target_qubit: usize) { let num_amplitudes = state.amplitudes.len(); for i in 0..num_amplitudes { // Check if bit at position target_qubit in i is 0 using a bitwise mask if (i \u0026amp; (1 \u0026lt;\u0026lt; target_qubit)) == 0 { let j = i + (1 \u0026lt;\u0026lt; target_qubit); // Same as i + 2^target_qubit let old_i = state.amplitudes[i]; let old_j = state.amplitudes[j]; let factor = 1.0 / f64::sqrt(2.0); // Compute new values let new_i = old_i.add(\u0026amp;old_j).scale(factor); let new_j = old_i.subtract(\u0026amp;old_j).scale(factor); // Update the state state.amplitudes[i] = new_i; state.amplitudes[j] = new_j; } } } The controlled-NOT (CNOT) gate flips the target qubit if and only if the control qubit is |1⟩. The implementation follows a similar pattern to the Hadamard gate but with different logic. We loop through all amplitude indices in the state vector. For each index, we check two conditions:\nIs the control qubit bit set to 1? (i \u0026amp; (1 \u0026lt;\u0026lt; control_qubit)) != 0 Is the target qubit bit set to 0? (i \u0026amp; (1 \u0026lt;\u0026lt; target_qubit)) == 0 If both conditions are true, we\u0026rsquo;ve found an amplitude pair that needs swapping. The CNOT gate only acts when the control is $\\ket{1}$. When it does act, it swaps amplitudes for basis states that differ in the target qubit. By checking if the target bit is 0, we process each pair exactly once - swapping index i with j = i ^ (1 \u0026lt;\u0026lt; target_qubit) (using XOR to flip just the target bit). For example, in the basis state |10⟩ (control=1, target=0), the CNOT swaps its amplitude with |11⟩ (control=1, target=1). But for |00⟩ (control=0), nothing happens because the control bit isn\u0026rsquo;t 1.\n/// Applies a CNOT gate to the specified qubit. /// /// The CNOT gate flips the target qubit if the control bit is |1⟩: /// /// If our control bit is 0 and the target bit is 1 we have this truth /// table; /// /// - |00\u0026gt; -\u0026gt; |00\u0026gt; /// - |01\u0026gt; -\u0026gt; |01\u0026gt; /// - |10\u0026gt; -\u0026gt; |11\u0026gt; /// - |11\u0026gt; -\u0026gt; |10\u0026gt; pub fn apply_cnot(state: \u0026amp;mut QuantumState, control_qubit: usize, target_qubit: usize) { let num_amplitudes = state.amplitudes.len(); for i in 0..num_amplitudes { // First check: is the control bit set to 1? if (i \u0026amp; (1 \u0026lt;\u0026lt; control_qubit)) != 0 { // only process when target bit is 0 if (i \u0026amp; (1 \u0026lt;\u0026lt; target_qubit)) == 0 { // Calculate the swap partner let j = i ^ (1 \u0026lt;\u0026lt; target_qubit); // XOR flips the target bit // Swap amplitudes[i] and amplitudes[j] state.amplitudes.swap(i, j); } } } } Circuit Struct # The circuit struct holds the information about the queue of gates and the number of qubits in the system. It needs to contain functions to add gates in order and be able to display the entire circuit to see what is going on.\n/// A quantum circuit consisting of a sequence of gates applied to qubits. pub struct Circuit { num_qubits: usize, gates: Vec\u0026lt;Gate\u0026gt;, } For the circuit struct implementation we have functions to:\nCreate a new circuit which creates an empty gate vector and a specified number of qubits for the system to keep a track of. A function which adds a gate to the queue, this takes a gate enum with the target information and pushes it to the vector. Some display functions for getting the number of qubits in the struct and a list of the gates for displaying the circuit. impl Circuit { /// Creates a new quantum circuit with the specified number of qubits. /// /// All qubits are initialized to |0⟩ when the circuit is executed. pub fn new(num_qubits: usize) -\u0026gt; Self { Circuit { num_qubits, gates: Vec::new() } } /// Adds a gate to the circuit. /// /// Gates are executed in the order they are added. pub fn add_gate(\u0026amp;mut self, gate: Gate) { self.gates.push(gate) } /// Returns the number of qubits in the circuit. pub fn num_qubits(\u0026amp;self) -\u0026gt; usize { self.num_qubits } /// Returns a slice of all gates in the circuit. pub fn gates(\u0026amp;self) -\u0026gt; \u0026amp;[Gate] { \u0026amp;self.gates } } Finally, we want a way to display the circuit using the println! macro. We can implement the fmt::Display trait for the Circuit struct to enable this. This implementation creates a vector of strings with one per qubit to track, and initialises the start of those strings by labelling the qubit number and appending \u0026ldquo;─\u0026rdquo; to represent a quantum wire. For each gate in the circuit, an identifier is pushed to the relevant string to specify whether the qubit has been changed by the gate or it\u0026rsquo;s been left alone with a wire segment. This vector of strings is then written to the console line-by-line, creating an ASCII circuit diagram.\nimpl fmt::Display for Circuit { fn fmt(\u0026amp;self, f: \u0026amp;mut fmt::Formatter) -\u0026gt; fmt::Result { // Create a vector of strings, one per qubit let mut lines: Vec\u0026lt;String\u0026gt; = Vec::new(); // Initialize each line with the qubit label for i in 0..self.num_qubits { lines.push(format!(\u0026#34;q{}: ─\u0026#34;, i)); } // Process each gate for gate in self.gates() { match gate { Gate::Hadamard { target } =\u0026gt; { for i in 0..self.num_qubits { match i { i if i == *target =\u0026gt; { lines[i].push(\u0026#39;H\u0026#39;); lines[i].push(\u0026#39;─\u0026#39;); }, _ =\u0026gt; { lines[i].push(\u0026#39;─\u0026#39;); lines[i].push(\u0026#39;─\u0026#39;); } } } }, Gate::CNOT { control, target } =\u0026gt; { for i in 0..self.num_qubits { match i { i if i == *target =\u0026gt; { lines[i].push(\u0026#39;C\u0026#39;); lines[i].push(\u0026#39;─\u0026#39;) }, i if i == *control =\u0026gt; { lines[i].push(\u0026#39;●\u0026#39;); lines[i].push(\u0026#39;─\u0026#39;) }, _ =\u0026gt; { lines[i].push(\u0026#39;─\u0026#39;); lines[i].push(\u0026#39;─\u0026#39;) } } } }, for line in lines { writeln!(f, \u0026#34;{}\u0026#34;, line)?; } Ok(()) } } Simulator # The final part of this project is the actual simulator which will apply all the gate functions to a state vector in order. This struct doesn\u0026rsquo;t need to store any information so we just need a default implementation for it.\n/// Simulator for the quantum circuit pub struct Simulator; impl Default for Simulator { fn default() -\u0026gt; Self { Simulator::new() } } When we want to run the simulator on the circuit, we pass in a reference to the circuit and the number of times to run the measurement. This then runs the internal run_once function n times. Inside run_once, we create a fresh quantum state initialised to |00\u0026hellip;0⟩, then for each gate in the circuit, we match the enum and apply the corresponding gate function to the quantum state. This process is repeated until the circuit is completed and then the state is finally measured and the result of that measurement is stored in a results vector. After the n runs are completed, the vector is returned with the result of every trial.\nimpl Simulator { /// Returns a new Simulator object to run a circuit. pub fn new() -\u0026gt; Self { Simulator } /// Run circuit n_shots times, return measurement results. pub fn run(\u0026amp;self, circuit: \u0026amp;Circuit, n_shots: usize) -\u0026gt; Vec\u0026lt;String\u0026gt; { let mut results = Vec::new(); for _ in 0..n_shots { results.push(self.run_once(circuit)); } results } // Helper: Execute circuit once and return final measurement fn run_once(\u0026amp;self, circuit: \u0026amp;Circuit) -\u0026gt; String { let mut state = QuantumState::new(circuit.num_qubits()); for gate in circuit.gates() { match gate { Gate::Hadamard { target } =\u0026gt; { gates::apply_hadamard(\u0026amp;mut state, *target); }, Gate::CNOT { control, target } =\u0026gt; { gates::apply_cnot(\u0026amp;mut state, *control, *target); }, } } state.measure() } /// Run circuit with the trace active to see the journey of the quantum state through /// the circuit. pub fn run_with_trace(\u0026amp;self, circuit: \u0026amp;Circuit) -\u0026gt; ExecutionTrace { let mut trace = ExecutionTrace { steps: Vec::new() }; let mut state = QuantumState::new(circuit.num_qubits()); // Capture initial state trace.steps.push(TraceStep { description: \u0026#34;Initial state\u0026#34;.to_string(), state: state.clone(), // We need to clone the state }); // Apply each gate and capture state after each for gate in circuit.gates() { match gate { Gate::Hadamard { target } =\u0026gt; { gates::apply_hadamard(\u0026amp;mut state, *target); trace.steps.push(TraceStep { description: format!(\u0026#34;Applied Hadamard to qubit {}\u0026#34;, *target), state: state.clone() }); }, Gate::CNOT { control, target } =\u0026gt; { gates::apply_cnot(\u0026amp;mut state, *control, *target); trace.steps.push(TraceStep { description: format!(\u0026#34;Applied CNOT (control: {}, target: {})\u0026#34;, *control, *target), state: state.clone() }); }, } } let result = state.measure(); let measured_index = usize::from_str_radix(\u0026amp;result, 2).unwrap(); // Set all amplitudes to 0, then set measured state to 1 for i in 0..state.amplitudes.len() { if i == measured_index { state.amplitudes[i] = Complex::new(1.0, 0.0); } else { state.amplitudes[i] = Complex::new(0.0, 0.0); } } trace.steps.push(TraceStep { description: format!(\u0026#34;Measurement result: {}\u0026#34;, result), state: state.clone(), }); trace } } I wasn\u0026rsquo;t satisfied with just this however, and wanted to see how the state evolves over time in the simulator. I created the run_with_trace function for this. This function works in the same way as the run function but a trace is also created to follow the state through the circuit. After every gate is applied, a copy of the current state is created and added to a struct called TraceStep along with a description of what just happened. These TraceStep structs are stored in an ExecutionTrace struct as a vector and with its display implementation, a trace of the state is created that allows a researcher to see what happened to the quantum state at every step.\n/// Struct to hold information of the current step for tracing. /// Holds a description of the step as well as the Quantum State. pub struct TraceStep { pub description: String, pub state: QuantumState, } /// Holds multiple TraceSteps to be iterated over when read. pub struct ExecutionTrace { pub steps: Vec\u0026lt;TraceStep\u0026gt;, } impl fmt::Display for ExecutionTrace { fn fmt(\u0026amp;self, f: \u0026amp;mut fmt::Formatter) -\u0026gt; fmt::Result { for (step_num, step) in self.steps.iter().enumerate() { writeln!(f, \u0026#34;Step {}: {}\u0026#34;, step_num, step.description)?; // Convert state to ket notation let ket = state_to_ket(\u0026amp;step.state); writeln!(f, \u0026#34; State: {}\u0026#34;, ket)?; writeln!(f)?; // blank line between steps } Ok(()) } } fn state_to_ket(state: \u0026amp;QuantumState) -\u0026gt; String { let mut terms = Vec::new(); for (index, amplitude) in state.amplitudes.iter().enumerate() { // Skip near-zero amplitudes if amplitude.magnitude_squared() \u0026lt; 1e-10 { continue; } // Convert index to binary basis state let basis = format!(\u0026#34;{:0width$b}\u0026#34;, index, width = state.num_qubits); // Format the coefficient (just the real part for now, assuming imaginary ≈ 0) let coeff = amplitude.real; terms.push(format!(\u0026#34;{:.4}|{}⟩\u0026#34;, coeff, basis)); } terms.join(\u0026#34; + \u0026#34;) } Results # Putting this all together, we end up with a working quantum circuit simulator that can track the quantum state vector and calculate the probability of a measurement. The following is an example of the Bell state creation code;\nWe start by initialising a mutable circuit with 2 qubits. With the mutable circuit we add a Hadamard gate targeting qubit 0. We then apply a controlled NOT gate on qubit 1 with qubit 0 being the control bit. A simulator struct is created and the circuit is ran 1000 times. The result vector is iterated over and we count the number of times the system is measured as \u0026ldquo;00\u0026rdquo; or \u0026ldquo;11\u0026rdquo;. As the qubits are entangled these should be the only outputs. Looking at the outputs of the code we can see the circuit diagram printed with the 2 qubits and the specified gates acting on them. From our measurements we get about a 50/50 chance of either measurement which is the expected behaviour, and this means the simulator works!\nuse phobos::{Circuit, Gate, Simulator, plot_histogram}; fn main() { // Create a Bell state circuit let mut circuit = Circuit::new(2); circuit.add_gate(Gate::Hadamard { target: 0 }); circuit.add_gate(Gate::CNOT { control: 0, target: 1 }); println!(\u0026#34;Circuit:\u0026#34;); println!(\u0026#34;{}\u0026#34;, circuit); // Run the circuit let sim = Simulator::new(); let results = sim.run(\u0026amp;circuit, 1000); // Count outcomes let mut count_00 = 0; let mut count_11 = 0; for result in \u0026amp;results { match result.as_str() { \u0026#34;00\u0026#34; =\u0026gt; count_00 += 1, \u0026#34;11\u0026#34; =\u0026gt; count_11 += 1, _ =\u0026gt; {} } } println!(\u0026#34;\\nResults from 1000 measurements:\u0026#34;); println!(\u0026#34;00: {} ({:.1}%)\u0026#34;, count_00, count_00 as f64 / 10.0); println!(\u0026#34;11: {} ({:.1}%)\u0026#34;, count_11, count_11 as f64 / 10.0); println!(\u0026#34;\\nProbability Distribution:\u0026#34;); plot_histogram(\u0026amp;results, circuit.num_qubits()); } Finished `dev` profile [unoptimized + debuginfo] target(s) in 6.99s Running `target/debug/examples/bell_state` Circuit: q0: ─H─●─ q1: ───C─ Results from 1000 measurements: 00: 485 (48.5%) 11: 515 (51.5%) Probability Distribution: 00: ❚❚❚❚❚❚❚❚❚❚❚❚❚❚❚❚❚❚❚❚❚❚❚❚❚❚❚❚❚❚❚❚❚❚❚❚❚❚❚❚❚❚❚❚❚❚❚❚ 01: 10: 11: ❚❚❚❚❚❚❚❚❚❚❚❚❚❚❚❚❚❚❚❚❚❚❚❚❚❚❚❚❚❚❚❚❚❚❚❚❚❚❚❚❚❚❚❚❚❚❚❚❚❚❚ If we ran this with the run_with_trace function, the following would have been the output. We can see the state evolving over time to get the final measurement. It should be noted, we display 0.7071 instead of 1/$\\sqrt{2}$ for an easier display function, as they can be used interchangeably.\nCircuit Trace: Step 0: Initial state State: 1.0000|00⟩ Step 1: Applied Hadamard to qubit 0 State: 0.7071|00⟩ + 0.7071|01⟩ Step 2: Applied CNOT (control: 0, target: 1) State: 0.7071|00⟩ + 0.7071|11⟩ Step 3: Measurement result: 00 State: 1.0000|00⟩ This project is still under development and can be found on my GitHub or with this link https://github.com/Zeos-ctrl/phobos\nIn the future I want to expand this project to also include some quantum machine learning processes, however this requires building a classical machine learning library in rust to mirror it. This classical project is ongoing and can be followed at https://github.com/Zeos-ctrl/deimos\n","date":"3 December 2025","externalUrl":null,"permalink":"/posts/creating-a-quantum-circuit-simulator/","section":"Posts","summary":"\u003cp\u003e\n\nRecently, I\u0026rsquo;ve been researching quantum mechanics, especially around quantum computing and I\u0026rsquo;ve been following a textbook on quantum machine learning. After using Python libraries like Cirq for the creation of circuits, I had the thought of creating a library in a language  I enjoy using like Rust. The goal of the first draft of the simulator was to create a simple Bell state circuit. This project has a bunch of parts;\u003c/p\u003e","title":"Creating a Quantum Circuit Simulator","type":"posts"},{"content":"","date":"3 December 2025","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"3 December 2025","externalUrl":null,"permalink":"/tags/quantum/","section":"Tags","summary":"","title":"Quantum","type":"tags"},{"content":"","date":"3 December 2025","externalUrl":null,"permalink":"/tags/rust/","section":"Tags","summary":"","title":"Rust","type":"tags"},{"content":"","date":"3 December 2025","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"18 November 2025","externalUrl":null,"permalink":"/tags/algorithms/","section":"Tags","summary":"","title":"Algorithms","type":"tags"},{"content":"{{\u0026lt; katex \u0026gt;}} Recently I picked up a textbook in Quantum Machine learning with python as it sounded interesting, and after finishing my Msc in Physics i felt like now was the time to get into it. In the textbook the author introduces the \u0026ldquo;Qubit\u0026rdquo;, a probabilistic bit that can be either a 1, 0 or a superposition between the two. Think of Schrodinger cat; The cat is either alive or dead, but until you open the box it is in a mixture of the two states. These quantum effects are what give us the phenomena of the double slit experiment where electrons can seem to go through both holes at once and there is a great video explaining this by Veritasium on YouTube (https://www.youtube.com/watch?v=qJZ1Ez28C-A).\nQuantum computing has been a field of research for many years, with The first experimental quantum computer was a 2-qubit nuclear magnetic resonance (NMR) device created in 1998, which demonstrated the feasibility of quantum computation by solving Deutsch\u0026rsquo;s problem (well get to this problem later). Since then companies Google have created quantum hardware using superconductivity which requires a massive setup that is cooled to sub-zero to achieve 105 Qubits (https://blog.google/technology/research/google-willow-quantum-chip/).\nWe are still many years away from having these systems in your home, and they are mainly useful for a small number of tasks as they are non-deterministic. If you give the system the same input, due to the very randomness of quantum mechanics, you are very unlikely to get the same output. Due to how they compute values however, we get an effect called quantum parallelisation.\nIn quantum parallelisation, a function is effectively evaluated over many possible inputs at once, because the quantum state of the system can represent a superposition of all those inputs simultaneously. Instead of checking each possibility one at a time, as a classical computer must, the quantum system evolves in a way that encodes information about all possibilities in a single operation. This gives us a probability distribution over the output of the function.\nThe catch is that when we finally measure the system, the superposition collapses, and we only observe one outcome. The art of quantum algorithm design is figuring out how to manipulate the system so that the correct or useful answers are much more likely to appear when measurement happens.\nWhile this kind of computation doesn’t give us “infinite speed,” it does offer speedups for very specific classes of problems, particularly those involving search, optimisation, and simulation of quantum systems themselves. In chapter 3 of the text book, we are introduced to a suite of quantum algorithms that exploit the non-deterministic nature of quantum computing to solve functions.\nThere are two main libraries set up to simulate quantum computing logic as we can\u0026rsquo;t just go out to the shop to buy our own quantum chip set. The first library, and the one I will be coding in the most, is Cirq from Google (https://quantumai.google/cirq) and the second is Qiskit from IBM (https://www.ibm.com/quantum/qiskit). The textbook came out in 2021 and since then these libraries have changes, as such some of these coding examples won\u0026rsquo;t be the same as in the book as they needed to be updated.\nSimulation of a Hadamard Gate # The first circuit is a simple Hadamard gate to put a single qubit into a superposition. In Cirq the Hadamard gate is denoted with the function H. What this circuit does, is we initalise a Qubit in the state $\\ket{0}$ and after going through the gate it has both states 0 and 1. After we run a measurement on the superposition, we force it into either the 1 state or the 0 state.\n# Import the Cirq package import cirq # Define a Qubit qubit = cirq.GridQubit(0,0) # Create a Circuit in cirq circuit = cirq.Circuit([cirq.H(qubit), cirq.measure(qubit,key=\u0026#39;m\u0026#39;)]) print(\u0026#34;Circuit Follows\u0026#34;) print(circuit) sim = cirq.Simulator() output = sim.run(circuit, repetitions=100) print(\u0026#34;Measurement Output:\u0026#34;) print(output) print(\u0026#34;Histogram stats follow\u0026#34;) print(output.histogram(key=\u0026#39;m\u0026#39;)) Output:\nCircuit Follows (0, 0): ───H───M(\u0026#39;m\u0026#39;)─── Measurement Output: m=1110000111010001111111111000001001010000111001111110001000100110011000011110110010100111101101110101 Histogram stats follow Counter({1: 54, 0: 46}) Qiskit stands for Quantum Information Science Kit and has 4 main components in its quantum computing stack.\nQiskit Terra: This provides all the essential components for building quantum circuits. Qiskit Aer: This is for the development of noise models for simulating realistic noisy simulations that can occur in real quantum computing devices. This also provides a C++ simulator framework. Qiskit Ignis: This is a framework for analysing and minimising noise in quantum circuits. Qiskit Agua: This contains cross-domain algorithms and logic to run these algorithms on a quantum real device or simulator. We can create the same program in this framework: import numpy as np from qiskit import QuantumCircuit from qiskit_aer import Aer from qiskit.visualization import plot_histogram # Use Aer\u0026#39;s simulator simulator = Aer.get_backend(\u0026#39;aer_simulator\u0026#39;) # Create a Quantum Circuit with 1 qubit and 1 classical bit circuit = QuantumCircuit(1, 1) # Add a Hadamard gate on qubit 0 circuit.h(0) # Measure qubit 0 into classical bit 0 circuit.measure(0, 0) # Execute the circuit job = simulator.run(circuit, shots=100) # Get the results result = job.result() # Extract counts counts = result.get_counts() print(f\u0026#34;\\nTotal count for 0 and 1 are: {counts}\u0026#34;) # Draw the circuit print(circuit.draw(output=\u0026#39;text\u0026#39;)) # Plot histogram plot_histogram(counts).show() Output\nTotal count for 0 and 1 are: {\u0026#39;1\u0026#39;: 58, \u0026#39;0\u0026#39;: 42} ┌───┐┌─┐ q: ┤ H ├┤M├ └───┘└╥┘ c: 1/══════╩═ 0 As you can see, the outputs of each program give us around a 50/50 split of 1\u0026rsquo;s and 0s. This means the qubit we created in a basis state of 0, after measurement had a 50/50 chance of flipping. It should be noted with more simulations, this number would grow closer to a true 50/50 split, instead of a 58/42 split for Qiskit.\nThe Hadamard transformation is a fundamental building block of quantum computing and will be used in every single following example. Take your time to look over the syntax of the code above to get a feel for how the circuit is initialised and the journey of the qubit through the system.\nBell State Creation and Measurement # The Bell State is a mechanism to cause entanglement between two Qubits, which means when they are in a superposition if we measure Qubit A as a 1 then we know Qubits B is also a 1. This is one of four possible Bell states;\nBell State Name Circuit Mathematical Form Measurement Correlations |Φ⁺⟩ Phi Plus H on q₀, then CNOT(q₀,q₁) $\\frac{1}{\\sqrt{2}}(\\|00\\rangle + \\|11\\rangle)$ Both qubits always match: 00 or 11 |Φ⁻⟩ Phi Minus H on q₀, CNOT(q₀,q₁), then Z on q₀ $\\frac{1}{\\sqrt{2}}(\\|00\\rangle - \\|11\\rangle)$ Both qubits always match: 00 or 11 |Ψ⁺⟩ Psi Plus H on q₀, CNOT(q₀,q₁), then X on q₁ $\\frac{1}{\\sqrt{2}}(\\|01\\rangle + \\|10\\rangle)$ Qubits always opposite: 01 or 10 |Ψ⁻⟩ Psi Minus H on q₀, CNOT(q₀,q₁), then X on q₁, then Z on q₀ $\\frac{1}{\\sqrt{2}}(\\|01\\rangle - \\|10\\rangle)$ Qubits always opposite: 01 or 10 The Bell State was named after John Bells 1964 theorem which proved that quantum entanglement produces correlations that can\u0026rsquo;t be explained by classical physics.\nIn the following we create the Bell state by first applying the Hadamard transform H on the qubit A initialised in state $\\ket{\\psi_A}=\\ket{0}$ to create the superposition state $\\ket{\\psi}_A=\\dfrac{1}{\\sqrt{2}}(\\ket{0}+\\ket{1})$ followed by applying the controlled NOT gate (CNOT) on qubit B initialised at state $\\ket{\\psi}_B = \\ket{0}$ based on qubit A as the control bit.\nimport cirq # Define the two qubits using LineQubit q_register = [cirq.LineQubit(i) for i in range(2)] # Define the Cirquit with a Hadamard gate on the qubit 0 followed by the CNOT # operation cirquit = cirq.Circuit([cirq.H(q_register[0]), cirq.CNOT(q_register[0], q_register[1])]) # Measure both the qubits cirquit.append(cirq.measure(*q_register,key=\u0026#39;z\u0026#39;)) print(\u0026#34;Circuit\u0026#34;) print(cirquit) # Define the simulator sim = cirq.Simulator() # Simulate the cirquit for 100 iterations output = sim.run(cirquit, repetitions=100) print(\u0026#34;Measurement Output\u0026#34;) print(output.histogram(key=\u0026#39;z\u0026#39;)) Output:\nCircuit 0: ───H───@───M(\u0026#39;z\u0026#39;)─── │ │ 1: ───────X───M──────── Measurement Output Counter({0: 51, 3: 49}) In Qiskit:\nimport numpy as np from qiskit import QuantumCircuit, execute, Aer from qiskit.visualization import plot_histogram # Use AER\u0026#39;s qasm_simulator simulator = Aer.get_backend(\u0026#39;qasm_simulator\u0026#39;) # Create a Quantum Circuit acting on the q register circuit = QuantumCircuit(2,2) # Add a H gate on qubit 0 circuit.h(0) # Add a CX gate on control qubit 0 and target qubit 1 circuit.cx(0,1) # Map the quantum mesurement to the classical bits circuit.measure([0,1], [0,1]) # Execute the circuit on the qasm simulator job = execute(circuit, simulator, shots=100) # Grab results from the job results = job.result() # Return counts counts = result.get_counts(circuit) print(f\u0026#34;\\nTotal count for 00 and 11 are: {counts}\u0026#34;) # Draw the circuit print(circuit.draw(output=\u0026#39;text\u0026#39;)) Output:\nTotal count for 00 and 11 are: {\u0026#39;11\u0026#39;: 42, \u0026#39;00\u0026#39;: 58} ┌───┐ ┌─┐ q_0: ┤ H ├──■──┤M├─── └───┘┌─┴─┐└╥┘┌─┐ q_1: ─────┤ X ├─╫─┤M├ └───┘ ║ └╥┘ c: 2/═══════════╩══╩═ 0 1 As we can see, we end up with a near 50/50 spread of entangled particles. If we had 100 particles and not 100 entanglements we know the circuit is incorrect.\nQuantum Teleportation # Quantum teleportation is the method of transmitting quantum states between a sender and a receiver without any communication channel. In quantum teleportation Alice and Bob get their control bit to share a Bell state through quantum entanglement. The following are the associated steps:\nInitialise the control qubits Q2 and Q3 to the state $\\ket{0}$ and the qubit Q1 to the state $\\ket{\\psi}$ to be transmitted. Create the bell state $\\dfrac{1}{\\sqrt{2}}(\\ket{00}+\\ket{11})$ between Q2 and Q3 by first applying Hadamard transform H on Q2 followed by the CNOT operation on Q3 where Q2 acts as the control bit. Once the Bell state is established between Alice\u0026rsquo;s and Bob\u0026rsquo;s control qubits Q2 and Q3, apply the CNOT operator on Alice\u0026rsquo;s two-qubit Q1 and Q2 where Q1 acts as the control qubit and Q2 acts as the target qubit Apply the Hadamard transform on qubit Q1 followed by measurement of Alice\u0026rsquo;s qubit Q1 and Q2. We denote the measurement states of Q1 and Q2 as M1 and M2. Apply the CNOT operator on Bob\u0026rsquo;s qubit Q3 based on the measured state M2 as the control qubit. Finally, apply the conditional Z operator on Bob\u0026rsquo;s qubit Q3 measured state M1. At this stage, Bob\u0026rsquo;s qubit Q3 has the state $\\ket{\\psi}$ that Alice has transmitted. I should add, this isn\u0026rsquo;t literal teleportation, what this circuit does is share a quantum state without telling the other person explicitly what that state is. This also doesn\u0026rsquo;t send information faster than light as we still need to send a classical signal to the other person telling them to take a measurement.\nimport cirq def quantum_teleportation(qubit_to_send_op=\u0026#39;H\u0026#39;, num_copies=100): Q1, Q2, Q3 = [cirq.LineQubit(i) for i in range(3)] cirquit = cirq.Circuit() \u0026#34;\u0026#34;\u0026#34; Q1: Alice State qubit to be sent to Bob Q2: Alices control qubit Q3: Bobs control qubit Set a state for Q1 based on qubit_to_send_op: Implemented operators H,X,Y,Z,I \u0026#34;\u0026#34;\u0026#34; if qubit_to_send_op == \u0026#39;H\u0026#39;: cirquit.append(cirq.H(Q1)) elif qubit_to_send_op == \u0026#39;X\u0026#39; or qubit_to_send_op == \u0026#39;Y\u0026#39;: cirquit.append(cirq.X(Q1)) elif qubit_to_send_op == \u0026#39;I\u0026#39;: cirquit.append(cirq.I(Q1)) else: raise NotImplementedError(\u0026#34;Yet to be implemented.\u0026#34;) # Entangle Alice and Bobs conterol qubits: Q2 and Q3 cirquit.append(cirq.H(Q2)) cirquit.append(cirq.CNOT(Q2, Q3)) # CNOT Alices data Qubit Q1 with control Qubit Q2 cirquit.append(cirq.CNOT(Q1, Q2)) # Transform Alices data with Qubit Q1 # on +/- basis using Hadamard Transform cirquit.append(cirq.H(Q1)) # Measure Alices qubit Q1 and Q2 cirquit.append(cirq.measure(Q1, Q2)) # Do a CNOT on Bobs qubit Q3 using Alices contol qubit Q2 after measurement cirquit.append(cirq.CNOT(Q2, Q3)) # DO a Conditioned Z Operation on Bobs qubit Q3 using Alices control qubit Q1 after measurement cirquit.append(cirq.CZ(Q1, Q3)) # Measure the final transmitted state to Bob in Q3 cirquit.append(cirq.measure(Q3, key=\u0026#39;Z\u0026#39;)) print(\u0026#34;Circuit\u0026#34;) print(cirquit) sim = cirq.Simulator() output = sim.run(cirquit, repetitions=num_copies) print(\u0026#34;Measurement Output\u0026#34;) print(output.histogram(key=\u0026#39;Z\u0026#39;)) quantum_teleportation(qubit_to_send_op=\u0026#39;H\u0026#39;) Output:\nCircuit 0: ───H───────@───H───M───────@──────────── │ │ │ 1: ───H───@───X───────M───@───┼──────────── │ │ │ 2: ───────X───────────────X───@───M(\u0026#39;Z\u0026#39;)─── Measurement Output Counter({1: 52, 0: 48}) From the measurement outcome, we see that Alice has transmitted the equal superposition state to Bob.\nQuantum Random Number Generator # Quantum systems are inherently non-deterministic, as such they become better generators for true random numbers as they do not rely on an initial seed. The following is an illustration of a random integer number generator routine using multiple qubits:\nDetermine the number of qubits required to represent the range of integer values to be sampled. For instance, if we have to sample from the eight integer numbers from 0-7, we would require $log_2(8)=3$ qubits. Create an equal superposition state by applying a Hadamard transform on each of the qubits initially in the $\\ket{0}$ state. The equal superposition state is given by the following: $$\\ket{\\psi}=H^{\\otimes n}\\ket{0}^\\otimes=\\dfrac{1}{2^{\\frac{n}{2}}}\\sum_{x=0}^{2^n-1}\\ket{x}$$ Here $\\ket{x}$ stands for the integer value for the computational basis state. Map the computational basis states to the actual integers and store the mapping in a dictionary. If the range of integral numbers to sample starts from zero, the dictionary from the computational basis state to actual integers can be just the binary to decimal transformation. We can make measurements on the equal superposition state $\\ket{\\psi}$ and map the measured basis state to the integer value using the dictionary map. import cirq import numpy as np def rng(low=0, high=2**10, m=10): \u0026#34;\u0026#34;\u0026#34; :param low: lower bound of numbers to be generated :param high: upper bound of numbers to be generated :param m: number of random numbers to output :return: list of random numbers \u0026#34;\u0026#34;\u0026#34; # Determine the number of Qubits required q_required = int(np.ceil(np.log2(high-low))) print(q_required) # Define the qubits Q_reg = [cirq.LineQubit(c) for c in range(q_required)] # Define the circuit circuit = cirq.Circuit() circuit.append([cirq.H(Q_reg[c]) for c in range(q_required)]) circuit.append(cirq.measure(*Q_reg, key=\u0026#39;z\u0026#39;)) print(circuit) # Simulate the circuit sim = cirq.Simulator() num_gen = 0 output = [] while num_gen \u0026lt; m: result = sim.run(circuit, repetitions=1) rand_number = result.data[\u0026#39;z\u0026#39;][0] + low if rand_number \u0026lt; high: output.append(rand_number) num_gen += 1 return output output = rng() print(output) Output:\n10 0: ───H───M(\u0026#39;z\u0026#39;)─── │ 1: ───H───M──────── │ 2: ───H───M──────── │ 3: ───H───M──────── │ 4: ───H───M──────── │ 5: ───H───M──────── │ 6: ───H───M──────── │ 7: ───H───M──────── │ 8: ───H───M──────── │ 9: ───H───M──────── [np.int64(536), np.int64(1015), np.int64(564), np.int64(831), np.int64(439), np.int64(576), np.int64(926), np.int64(475), np.int64(386), np.int64(1016)] We are given 10 random numbers as outputs between our upper and lower bounds.\nDeutsch-Jozsa Algorithm # The Deutsch-Jozsa algorithm determines if a function is balanced, meaning the function responds with exactly half of the outputs being a 1 and the other half being a 0, or constant if the function responds with 100% 1s or 0s. This problem was designed to prove that quantum computers could provide an exponential speed-up over their classical, deterministic counterparts.\nWe are given a black box function, where we cannot see how it works and can only give it an input and receive an output. For this algorithm, we need to create an oracle to evaluate the function. The following code is an example of this algorithm.\nimport cirq import numpy as np def oracle(data_reg, y_reg, circuit, is_balanced=True, oracle_type=0): \u0026#34;\u0026#34;\u0026#34; Creates an oracle for the function. For balanced: implements a function that outputs 1 for half the inputs For constant: implements a function that outputs 0 or 1 for all inputs \u0026#34;\u0026#34;\u0026#34; if is_balanced: # Example balanced oracle: f(x) = x_0 XOR x_1 (for 2+ qubits) # This can be implemented with CNOTs for i in range(len(data_reg)): circuit.append(cirq.CNOT(data_reg[i], y_reg)) else: # Constant function if oracle_type == 1: # Constant 1: flip the target circuit.append(cirq.X(y_reg)) # Constant 0: do nothing return circuit def deutsch_jozsa(domain_size: int, func_type_to_simulate: str = \u0026#34;balanced\u0026#34;, copies: int = 1): \u0026#34;\u0026#34;\u0026#34; Deutsch-Jozsa algorithm implementation \u0026#34;\u0026#34;\u0026#34; reqd_num_qubits = int(np.ceil(np.log2(domain_size))) data_reg = [cirq.LineQubit(c) for c in range(reqd_num_qubits)] y_reg = cirq.LineQubit(reqd_num_qubits) circuit = cirq.Circuit() # Prepare target qubit in |-\u0026gt; state circuit.append(cirq.X(y_reg)) circuit.append(cirq.H(y_reg)) # Apply Hadamard to all input qubits circuit.append([cirq.H(data_reg[c]) for c in range(reqd_num_qubits)]) # Apply oracle if func_type_to_simulate == \u0026#39;balanced\u0026#39;: is_balanced = True else: is_balanced = False circuit = oracle(data_reg, y_reg, circuit, is_balanced=is_balanced) # Apply Hadamard to input qubits again circuit.append([cirq.H(data_reg[c]) for c in range(reqd_num_qubits)]) # Measure input qubits circuit.append(cirq.measure(*data_reg, key=\u0026#39;result\u0026#39;)) print(\u0026#34;Circuit Diagram:\u0026#34;) print(circuit) # Run simulation sim = cirq.Simulator() result = sim.run(circuit, repetitions=copies) # Interpret results measurements = result.measurements[\u0026#39;result\u0026#39;] all_zeros = np.all(measurements == 0) print(f\u0026#34;Measurements: {result.histogram(key=\u0026#39;result\u0026#39;)}\u0026#34;) if all_zeros: print(\u0026#34;Result: CONSTANT function\u0026#34;) else: print(\u0026#34;Result: BALANCED function\u0026#34;) return all_zeros # True if constant, False if balanced print(\u0026#34;Execute Deutsch-Jozsa for a Balanced Function:\u0026#34;) deutsch_jozsa(domain_size=4, func_type_to_simulate=\u0026#39;balanced\u0026#39;, copies=1000) print(\u0026#34;\\nExecute Deutsch-Jozsa for a Constant Function:\u0026#34;) deutsch_jozsa(domain_size=4, func_type_to_simulate=\u0026#39;constant\u0026#39;, copies=1000) Output:\nExecute Deutsch-Jozsa for a Balanced Function: Circuit Diagram: 0: ───H───────@───H───────M(\u0026#39;result\u0026#39;)─── │ │ 1: ───H───────┼───@───H───M───────────── │ │ 2: ───X───H───X───X───────────────────── Measurements: Counter({3: 1000}) Result: BALANCED function Execute Deutsch-Jozsa for a Constant Function: Circuit Diagram: 0: ───H───H───M(\u0026#39;result\u0026#39;)─── │ 1: ───H───H───M───────────── 2: ───X───H───────────────── Measurements: Counter({0: 1000}) Result: CONSTANT function For a constant function, all computational basis states acquire the same global phase, so the final Hadamards cause constructive interference back to the |00⟩ state, yielding measurement outcome 0. For a balanced function, exactly half the basis states pick up a positive phase and half pick up a negative phase (opposite signs). When the final Hadamards are applied, this creates destructive interference for the |00⟩ component and constructive interference for other states, guaranteeing a non-zero measurement (in this case, binary 11 = decimal 3). Measuring 0 means constant, measuring anything else means balanced with 100% certainty from just one execution.\nGrovers Algorithm # The last algorithm ill be writing about is Grovers algorithm.One of the potential advantages of quantum systems is the speed at witch it can access database elements. Grover\u0026rsquo;s algorithm is an algorithm that can provide a quadratic speedup in searching items from a database using the amplitude amplification trick.\nImagine you have an unsorted database with N items, and exactly one of them is the \u0026ldquo;winner\u0026rdquo; you\u0026rsquo;re searching for. Classically, you\u0026rsquo;d need to check about N/2 items on average. Grover\u0026rsquo;s algorithm works in two repeated steps that amplify the probability amplitude of the marked item:\nJust like in Deutsch-Jozsa, an oracle applies a phase flip to the state you\u0026rsquo;re looking for. If you\u0026rsquo;re searching for |winner⟩, it applies: |winner⟩ → -|winner⟩ (flips its phase to negative). All other states stay positive. So you start with equal superposition over all N items, then selectively flip the phase of just the winner. Now the winner has negative amplitude while everything else is positive. Next you apply an operation that inverts all ampliitudes about their average value. If one item has a negative amplitude and all the others are positive, the average is slightly below the positive values. When inverting around this average, the negative amplitude (below average) flips to become more positive than it was, and the positive amplitudes (above average) decrease slightly. These two steps are repeated √N times and the winners amplitude grows to nearly 1 while the others shrink to nearly 0. Then when we measure the result, we get the winner with a high probability. In the following oracle we set the database element to be at \u0026lsquo;01\u0026rsquo; so we should get that item with 100% accuracy afterwards. import cirq import numpy as np def oracle(input_qubits, target_qubit, circuit, secret_element=\u0026#39;01\u0026#39;): print(f\u0026#34;Element to be searched: {secret_element}\u0026#34;) # Flip the qubits corresponding to the bits containing 0 for i, bit in enumerate(secret_element): if int(bit) == 0: circuit.append(cirq.X(input_qubits[i])) # Do a conditional NOT using all input qubits as control qubits circuit.append(cirq.TOFFOLI(*input_qubits, target_qubit)) # Revert the input qubits to the secret state prior to flipping for i, bit in enumerate(secret_element): if int(bit) == 0: circuit.append(cirq.X(input_qubits[i])) return circuit def grovers_algorithm(num_qubits=2, copies=1000): # Define input and output qubits input_qubits = [cirq.LineQubit(i) for i in range(num_qubits)] target_qubit = cirq.LineQubit(num_qubits) circuit = cirq.Circuit() # Create equal Superposition state circuit.append([cirq.H(input_qubits[i]) for i in range(num_qubits)]) # Take target qubit to minus state circuit.append([cirq.X(target_qubit), cirq.H(target_qubit)]) # Pass the qubit through the Oracle circuit = oracle(input_qubits, target_qubit, circuit) # Construct Grover operator circuit.append(cirq.H.on_each(*input_qubits)) circuit.append(cirq.X.on_each(*input_qubits)) circuit.append(cirq.H.on(input_qubits[1])) circuit.append(cirq.CNOT(input_qubits[0], input_qubits[1])) circuit.append(cirq.H.on(input_qubits[1])) circuit.append(cirq.X.on_each(*input_qubits)) circuit.append(cirq.H.on_each(*input_qubits)) # Measure the result circuit.append(cirq.measure(*input_qubits, key=\u0026#39;Z\u0026#39;)) print(\u0026#34;Grovers algorithm follows\u0026#34;) print(circuit) sim = cirq.Simulator() result = sim.run(circuit, repetitions=copies) out = result.histogram(key=\u0026#39;Z\u0026#39;) out_result = {} for k in out.keys(): new_key = \u0026#34;{0:b}\u0026#34;.format(k) if len(new_key) \u0026lt; num_qubits: new_key = (num_qubits - len(new_key)) * \u0026#39;0\u0026#39; + new_key out_result[new_key] = out[k] print(out_result) grovers_algorithm(2) Output:\nElement to be searched: 01 Grovers algorithm follows 0: ───H───X───@───X───H───X───@───X───H───────M(\u0026#39;Z\u0026#39;)─── │ │ │ 1: ───H───────@───H───X───H───X───H───X───H───M──────── │ 2: ───X───H───X──────────────────────────────────────── {\u0026#39;01\u0026#39;: 1000} From the output we can see that Grover\u0026rsquo;s algorithm has converged to the winner with 100 percent probability. Now we might look at this and think there is no use case for such an algorithm as we already require an oracle that knows the location of the item. This isn\u0026rsquo;t 100% accurate. The oracle doesn\u0026rsquo;t know where the item is but it can recognise it using the function. Suppose you\u0026rsquo;re searching for a solution to a Sudoku puzzle. You don\u0026rsquo;t know the solution (that\u0026rsquo;s what you\u0026rsquo;re searching for!), but given any candidate solution, you can verify if it\u0026rsquo;s correct by checking the Sudoku rules. The oracle implements this verification. So the oracle is not \u0026ldquo;tell me where the answer is\u0026rdquo; (that would be cheating!), but \u0026ldquo;given a candidate answer, tell me if it\u0026rsquo;s correct\u0026rdquo;\nThe main advantage of this over a classical search algorithm is in quantum parallelisation. We can put all N items into a superposition simultaneously, and when we apply the oracle, it evaluates all N items simultaneously in that superposition.\nConclusion # We have seen some background to quantum computing as well as some examples of quantum algorithms. The true promise of quantum computing is quantum parallelisation, as we saw in the Grovers algorithm example.\nWe\u0026rsquo;ve progressed from the fundamental building blocks of quantum computation, the Hadamard gate creating superposition, to algorithms that exploit quantum mechanics for computational advantage. The Bell states demonstrated quantum entanglement, showing how measuring one qubit instantaneously determines the state of its entangled partner. Quantum teleportation illustrated how quantum states can be transmitted using entanglement and classical communication, while our quantum random number generator showed the inherently non-deterministic nature of quantum measurement.\nThe Deutsch-Jozsa and Grover\u0026rsquo;s algorithms represent the paradigm shift that quantum computing offers. Rather than checking possibilities sequentially as classical computers must, these algorithms leverage quantum superposition to evaluate multiple inputs simultaneously, then use interference (constructive and destructive) to amplify correct answers while suppressing incorrect ones. The Deutsch-Jozsa algorithm achieves this in a single query with 100% certainty, while Grover\u0026rsquo;s algorithm provides a quadratic speedup for unstructured search, requiring only √N operations instead of N.\nWhile we\u0026rsquo;re still years away from having quantum computers in our homes, and current applications remain limited to specific problem domains, the theoretical foundations and simulation tools like Cirq and Qiskit allow us to prepare for the quantum future.\nI\u0026rsquo;ve created a GitHub repository with some notebooks with example code in them from the Quantum Machine Learning With Python textbook im using, found at https://github.com/Zeos-ctrl/QuantumM\n","date":"18 November 2025","externalUrl":null,"permalink":"/posts/quantum-algorithms/","section":"Posts","summary":"\u003cp\u003e{{\u0026lt; katex \u0026gt;}}\nRecently I picked up a textbook in Quantum Machine learning with python as it sounded interesting, and after finishing my Msc in Physics i felt like now was the time to get into it. In the textbook the author introduces the \u0026ldquo;Qubit\u0026rdquo;, a probabilistic bit that can be either a 1, 0 or a superposition between the two. Think of Schrodinger cat; The cat is either alive or dead, but until you open the box it is in a mixture of the two states. These quantum effects are what give us the phenomena of the double slit experiment where electrons can seem to go through both holes at once and there is a great video explaining this by Veritasium on YouTube (\u003ca\n  href=\"https://www.youtube.com/watch?v=qJZ1Ez28C-A%29\"\n    target=\"_blank\"\n  \u003ehttps://www.youtube.com/watch?v=qJZ1Ez28C-A)\u003c/a\u003e.\u003c/p\u003e","title":"Quantum Algorithms","type":"posts"},{"content":"","date":"13 October 2025","externalUrl":null,"permalink":"/tags/gravitational_waves/","section":"Tags","summary":"","title":"Gravitational_waves","type":"tags"},{"content":"","date":"13 October 2025","externalUrl":null,"permalink":"/tags/machine_learning/","section":"Tags","summary":"","title":"Machine_learning","type":"tags"},{"content":" During the course of my Master\u0026rsquo;s degree in Data Intensive Physics, I spent my time learning how machine learning algorithms work and how to analyze gravitational wave signals. The main way we analyzed the data from gravitational waves was to do parameter estimation to try and estimate some of the parameters of the black holes that merged to create the waveform. During my \u0026lsquo;Observational Gravitational Wave Astronomy\u0026rsquo; module, this culminated in a final project where we used Markov Chain Monte Carlo methods to estimate the parameters of GW150914, which was the first detected signal. This analysis consisted of using a surrogate generator (a program to generate a waveform), overlapping the generated waveform with the detected signal, measuring how similar they are, and repeating this process until we find the best match between the generated and measured signals. As you could probably tell, one of the bottlenecks in this system is the generation of the waveforms. There are multiple waveform families, which I won\u0026rsquo;t go into in this post, but the main ones we looked at are Inspiral-Merger-Ringdown Phenomenological models (IMRPhenom) and Effective-One-Body models (EOB). These models simulate the same merger but use different mathematics to accomplish that. The IMR waveforms are less accurate but faster to generate, while the EOB models are more accurate but take a lot longer to produce. To overcome the generation time constraint, researchers generate \u0026ldquo;Waveform banks,\u0026rdquo; which are precomputed waveforms that can be used within parameter estimation pipelines. These waveform banks typically contain 100,000 to 1,000,000 signals, making them large and time-consuming to generate.\n![[2025-10-13-131804_907x341_scrot.png]]\nFor my summer project, I ended up working on a parameter estimation pipeline using Simulation-Based Inference (SBI). TL;DR: SBI works by running lots of realistic simulations and letting a machine-learning model learn which source parameters match the observed data. This makes it much faster and easier to obtain reliable parameter estimates and uncertainties. To train a reliable model, you require a massive waveform bank, which would take a long time to generate. This is where my summer project came in, as I wanted to create a model that would learn the function of the mergers and generate waveforms quickly.\nBackground # Initially, I thought of using Fourier Neural Operators (FNO) to learn the partial derivative functions behind the black hole evolution equations. FNOs are machine learning networks that learn partial differential equations and have been used to model systems like fluid evolution (https://zongyi-li.github.io/blog/2020/fourier-pde/). The idea was that the model would take in some randomly generated input parameters and produce a gravitational wave signal. It didn\u0026rsquo;t work. The problem with trying to learn an oscillating signal is spectral bias, where a model learns the low-frequency target first and fails at learning the high-frequency part. This results in a signal that generalises well initially but then fails spectacularly.\n![[2025-10-13-spectral-bias.png]]\nTo solve this I needed to either:\nUse a model which could work around spectral bias. Or simplify the input we are trying to learn. I went with both options. The Model # To work around spectral bias, I split my model into smaller sub-models, which we will call banks, and had them learn a small section of the target waveform. This way, the model doesn\u0026rsquo;t just learn the low-frequency and high-frequency sections at the same time, but the final signal is the summation of all the predictions from the smaller models. This parallelisation makes learning easier.\nThe next way to make it easier to learn, is to change the input data. Oscillating data is hard to model so I though about decomposing it into an Amplitude and Phase target. By learning and predicting amplitude and phase, the waveform can be reconstructed by the formula, $$h_+(t) = A(t)cos(\\phi(t)),h_\\times = A(t)sin(\\phi(t))$$ Where $h_+$ and $h_\\times$ represent the polarisation of the signal. In the plots below I have the amplitude and phase change over time. The amplitude is the strength of the signal, and the phase follows where the objects are in their orbit.\n![[2025-10-13-135522_460x169_scrot.png]]\nThese are much simpler and easier to work with, and as a result, we get a model that can learn the functions well. We now have the inputs and targets for our model. We use the masses and spins of the black holes as inputs and have the amplitude and phase as targets. I generated the data using PyCBC and decomposed the generated waveform into the two arrays ready for training. The figure below shows the network structure. I joined the normalised arrays for both targets with the input parameters and trained a regression network. There are two networks that need to be trained, one for each target. These networks are made up of $k$ \u0026ldquo;banks,\u0026rdquo; which are subnetworks used to make the learning process easier. After they are trained, we can use the amplitude and phase predictions to reconstruct the model.\n![[2025-10-13-133258_214x408_scrot.png]]\nA few additional things the network does involves estimating the uncertainty of its predictions using a Laplacian (Laplace) approximation over the final weights of the amplitude network.\nImagine the network’s loss landscape as a mountain range spread over a grid where each point in that grid represents a possible configuration of the network’s weights. The valleys in this range correspond to regions where the model fits the data well. Now, the Laplacian doesn’t measure how high the mountains are, instead, it measures how sharp or wide the valleys are around their lowest points. A steep, narrow valley means the network is confident as small shifts in weights quickly make things worse, while a wide, gentle valley means it’s less certain. In essence, the Laplacian captures the curvature of that landscape, turning the hidden shape of the mountains into a measure of how confident the model is in its predictions. After completing this network, I tested it against PyCBC for generation speed and accuracy.\nResults # Speed of Inference # The first test I did was generate a bunch of waveforms using PyCBC and my network to compare how fast the network is at inference. This network uses GPU batch generation, where I can get an array of inputs and, in one forward pass, obtain the corresponding outputs. The table below shows this comparison for generating 10, 100, and 1000 waveforms in seconds. For single inference, my model was comparable to the IMRPhenomD approximant. However, for batch generation, it was significantly faster.\nModel $n=10$ $n=100$ $n=1000$ SEOBNRv4 1.954 19.601 196.136 IMRPhenomD 0.102 0.557 5.627 My Model Single Gen 0.318 0.548 5.940 My Model Batch Gen 0.013 0.138 1.406 This is great and all, but if the model isn\u0026rsquo;t accurate, this research has been worthless. To test the accuracy, I generated two waveforms using the same prior parameters and used the inner dot product match to see how similar they are. The following was using the IMRPhenomD approximant, and my model achieved a match of $\\approx 0.992$.\n![[2025-10-13-waveform_plots.png]]\nAccuracy compared to the ground truth # To test the reliability of the model, I conducted the same test with 1000 different prior parameters. The following shows the results. The IMRPhenom model had a mean accuracy of approximately 0.98, whereas the SEOBNRv4 model had an accuracy of approximately 0.610. The low accuracy of the EOB model was due to a poor set of hyperparameters, which I didn\u0026rsquo;t have time to change for my final tests, as the deadline was a day away when the final tests were performed. As a side note, training on a dataset of 10,000 samples took about a day on my PC at home\u0026hellip; To run 50 hyperparameter tuning runs, it took a day per model. My computer isn\u0026rsquo;t even that slow, it has a Radeon RX 6800 graphics card, a Ryzen 5 3600 CPU, and 16 GB of RAM.\n![[2025-10-13-comparison_n1000.png]]\nSBI # Finally, I tested this network in SBI, which is what this entire project was about, a week before the deadline. This definitely didn\u0026rsquo;t do me any favors, as I worked long nights to get this model integrated into a separate codebase. Eventually, however, I managed to get a training run in using my generated waveforms and obtained the following results!\n![[2025-10-13-corner_plot.png]]\nIdeally, you want the blue cross to be in the jelly bean shape in the bottom left plot, as this is the injected value. The orange plot is using Bilby, and the green plot is using the SBI project I was a part of. The jelly bean shape on the SBI plot is much larger and off-center compared to Bilby, which could be due to not enough training data or poor hyperparameters in the model. Even though I know it\u0026rsquo;s not better than the pre-established Bilby project, I\u0026rsquo;m just glad the SBI network was able to learn from my generator.\nFinal Thoughts # I set out to create a waveform generator to accelerate the construction of gravitational wave templates for parameter estimation, and I was somewhat successful! My model was able to generate data that matched the input data with a high degree of accuracy, and I was able to integrate the project within another project.\nThis project has a lot of room for expansion:\nTrain more networks on different waveform approximants Train on wider priors, so we can generate a larger waveform bank Update the model to train on noise or even long lived Neutron star mergers This project is still under development and has a GitHub repo at https://github.com/Zeos-ctrl/SPECTRE if you want to play around with it!\n","date":"13 October 2025","externalUrl":null,"permalink":"/posts/making-a-gravitational-waveform-generator-using-machine-learning/","section":"Posts","summary":"\u003cp\u003e\n\nDuring the course of my Master\u0026rsquo;s degree in Data Intensive Physics, I spent my time learning how machine learning algorithms work and how to analyze gravitational wave signals. The main way we analyzed the data from gravitational waves was to do parameter estimation to try and estimate some of the parameters of the black holes that merged to create the waveform. During my \u0026lsquo;Observational Gravitational Wave Astronomy\u0026rsquo; module, this culminated in a final project where we used Markov Chain Monte Carlo methods to estimate the parameters of GW150914, which was the first detected signal. This analysis consisted of using a surrogate generator (a program to generate a waveform), overlapping the generated waveform with the detected signal, measuring how similar they are, and repeating this process until we find the best match between the generated and measured signals. As you could probably tell, one of the bottlenecks in this system is the generation of the waveforms. There are multiple waveform families, which I won\u0026rsquo;t go into in this post, but the main ones we looked at are Inspiral-Merger-Ringdown Phenomenological models (IMRPhenom) and Effective-One-Body models (EOB). These models simulate the same merger but use different mathematics to accomplish that. The IMR waveforms are less accurate but faster to generate, while the EOB models are more accurate but take a lot longer to produce. To overcome the generation time constraint, researchers generate \u0026ldquo;Waveform banks,\u0026rdquo; which are precomputed waveforms that can be used within parameter estimation pipelines. These waveform banks typically contain 100,000 to 1,000,000 signals, making them large and time-consuming to generate.\u003c/p\u003e","title":"Making A Gravitational Waveform Generator Using Machine Learning","type":"posts"},{"content":"","date":"13 October 2025","externalUrl":null,"permalink":"/tags/parameter_estimation/","section":"Tags","summary":"","title":"Parameter_estimation","type":"tags"},{"content":"BSc in Computer Security and MSc in Data-Intensive Physics, specializing in Machine Learning/AI, Gravitational Wave Analysis, and Cryptography. Former GB athlete, I focused on time management and incremental goals to excel in sports. Transitioned to coaching to mentor athletes and foster their growth. Mental health advocate for athletes, founding a movement to promote enjoyment and recognize their value beyond sport. Pursuing a PhD in gravitational wave science or AI ethics\n","date":"7 October 2025","externalUrl":null,"permalink":"/about/","section":"Connor Bryan","summary":"\u003cp\u003eBSc in Computer Security and MSc in Data-Intensive Physics, specializing in Machine Learning/AI, Gravitational Wave Analysis, and Cryptography. Former GB athlete, I focused on time management and incremental goals to excel in sports. Transitioned to coaching to mentor athletes and foster their growth. Mental health advocate for athletes, founding a movement to promote enjoyment and recognize their value beyond sport. Pursuing a PhD in gravitational wave science or AI ethics\u003c/p\u003e","title":"About","type":"page"},{"content":" Experience Link Role Dates Location Tribela Head of Engineering 2025 - Present Hybrid - Oxford, UK Zeos Systems Founder 2024 - 2025 Remote Abingdon Vale Swimming Club Level 1 Swimming Coach 2022 - Present Remote Darren Bryan Security Services Access Control Engineer 2018 - Present Oxford, UK Education Link Degree Date Cardiff University MSc Data Intensive Physics Sept. 2024 - Sept. 2025 (expected) Cardiff Metropolitan BSc Cyber Security (1st Class Hons) Sept. 2021 - Jun. 2024 Oxford City College Extended Diploma in Engineering (MMM) Sep. 2018 - Jun. 2020 ","date":"7 October 2025","externalUrl":null,"permalink":"/resume/","section":"Connor Bryan","summary":"\u003ch2 class=\"relative group\"\u003eExperience \n    \u003cdiv id=\"experience\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n\u003c/h2\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n    \u003ctr\u003e\n      \u003cth\u003eLink\u003c/th\u003e\n      \u003cth\u003eRole\u003c/th\u003e\n      \u003cth\u003eDates\u003c/th\u003e\n      \u003cth\u003eLocation\u003c/th\u003e\n    \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003ca href=\"https://tribela.com\" target=\"_blank\"\u003eTribela\u003c/a\u003e\u003c/td\u003e\n      \u003ctd\u003eHead of Engineering\u003c/td\u003e\n      \u003ctd\u003e2025 - Present\u003c/td\u003e\n      \u003ctd\u003eHybrid - Oxford, UK\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003ca href=\"http://www.zeos.systems\" target=\"_blank\"\u003eZeos Systems\u003c/a\u003e\u003c/td\u003e\n      \u003ctd\u003eFounder\u003c/td\u003e\n      \u003ctd\u003e2024 - 2025\u003c/td\u003e\n      \u003ctd\u003eRemote\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003ca href=\"#\" target=\"_blank\"\u003eAbingdon Vale Swimming Club\u003c/a\u003e\u003c/td\u003e\n      \u003ctd\u003eLevel 1 Swimming Coach\u003c/td\u003e\n      \u003ctd\u003e2022 - Present\u003c/td\u003e\n      \u003ctd\u003eRemote\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003ca href=\"https://darrenbryansecurityservices.co.uk\" target=\"_blank\"\u003eDarren Bryan Security Services\u003c/a\u003e\u003c/td\u003e\n      \u003ctd\u003eAccess Control Engineer\u003c/td\u003e\n      \u003ctd\u003e2018 - Present\u003c/td\u003e\n      \u003ctd\u003eOxford, UK\u003c/td\u003e\n    \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\n\u003ch2 class=\"relative group\"\u003eEducation \n    \u003cdiv id=\"education\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n\u003c/h2\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n    \u003ctr\u003e\n      \u003cth\u003eLink\u003c/th\u003e\n      \u003cth\u003eDegree\u003c/th\u003e\n      \u003cth\u003eDate\u003c/th\u003e\n    \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003ca href=\"https://www.cardiff.ac.uk\" target=\"_blank\"\u003eCardiff University\u003c/a\u003e\u003c/td\u003e\n      \u003ctd\u003eMSc Data Intensive Physics\u003c/td\u003e\n      \u003ctd\u003eSept. 2024 - Sept. 2025 (expected)\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003ca href=\"https://www.cardiffmet.ac.uk\" target=\"_blank\"\u003eCardiff Metropolitan\u003c/a\u003e\u003c/td\u003e\n      \u003ctd\u003eBSc Cyber Security (1st Class Hons)\u003c/td\u003e\n      \u003ctd\u003eSept. 2021 - Jun. 2024\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003ca href=\"#\" target=\"_blank\"\u003eOxford City College\u003c/a\u003e\u003c/td\u003e\n      \u003ctd\u003eExtended Diploma in Engineering (MMM)\u003c/td\u003e\n      \u003ctd\u003eSep. 2018 - Jun. 2020\u003c/td\u003e\n    \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e","title":"Resume","type":"page"},{"content":"","date":"6 October 2025","externalUrl":null,"permalink":"/tags/github/","section":"Tags","summary":"","title":"Github","type":"tags"},{"content":"","date":"6 October 2025","externalUrl":null,"permalink":"/tags/hugo/","section":"Tags","summary":"","title":"Hugo","type":"tags"},{"content":"{{\u0026lt; katex \u0026gt;}} For a while, I\u0026rsquo;ve wanted to start a blog to share my ideas and try to articulate what I\u0026rsquo;ve learned. Before this iteration of the blog, I tried using a template YAML file within JavaScript to create blog posts. This approach was terrible; it was hard to see any syntax or even format it properly afterward. Sometimes, it\u0026rsquo;s better to use already developed tools and techniques. That\u0026rsquo;s where I found an amazing video by NetworkChuck about setting up a content pipeline using Obsidian to create the Markdown files for a blog, and using a templater such as Hugo to turn them into pretty webpages like the one you are reading now. In this post, I will go over the steps I took to create this blog, and hopefully inspire you to create one as it\u0026rsquo;s so easy E7c0ELEH8 \u0026gt;}}\nSetting up Obsidian # The first thing we will do is install Obsidian and set up our blog posts directory. Obsidian is a note-taking and organisation tool that I\u0026rsquo;ve started to love using. You can organise markdown notes and content in folders to create a \u0026ldquo;second brain.\u0026rdquo; There are tools to set up personalised daily notes so you can track habits and create diaries. This content is synced between devices on your account as well. Download the app from https://obsidian.md/ and go through the setup.\nAfter you have setup Obsidian:\nCreate a new folder where you will put all you blog posts, I labelled mine \u0026ldquo;posts\u0026rdquo;. You can start to write your posts in this directory, all you need now is the path to the directory. Right click the folder and select \u0026ldquo;reveal in explorer\u0026rdquo;. Keep a note of this path as we will need it later. In order for the blog to have a title and tags we need to set some properties, all you need to add to the top of your document is.\n--- title: Making a Tech Blog using Hugo and Obsidian date: 2025-10-06 draft: false tags: - tag1 - tag2 --- Setting up Hugo # Firstly, install Git (https://github.com/git-guides/install-git) and Go (https://go.dev/dl/) and follow the steps to install for your system at https://gohugo.io/installation/. The installation is simple for Linux, as you can install it with your package manager. After everything is installed, you can start creating your website.\n## Verify Hugo works hugo version ## Create a new site hugo new site sitename cd sitename Update \u0026ldquo;sitename\u0026rdquo; with the project name. Next, you need to theme your site. My site uses Blowfish as a theme (https://blowfish.page/); however, an entire list of themes can be found here: https://themes.gohugo.io/. Follow the instructions to install the theme in your Hugo site. The easiest way is to use a Git submodule, however. WARNING: These commands will differ depending on the theme; follow the instructions on the theme page.\n## Initialize a git repository (Make sure you are in your Hugo website directory) git init ## Set global username and email parameters for git git config --global user.name \u0026#34;Your Name\u0026#34; git config --global user.email \u0026#34;your.email@example.com\u0026#34; ## Install a theme (we are installing the Blowfish theme here) ## Find a theme ---\u0026gt; https://themes.gohugo.io/ git submodule add -b main https://github.com/nunocoracao/blowfish.git themes/blowfish ## Delete the hugo generated config and copy the blowfish configs into config/_default mkdir config/_default cp themes/blowfish/config/_default/* config/_default/ rm hugo.toml You can go through and update the config so you site looks how you want it to. After you\u0026rsquo;ve configured your site you can now test it with:\n## Verify Hugo works with your theme by running this command hugo server -t themename Getting content on your site # All your content for the website lives in the \u0026ldquo;content\u0026rdquo; folder. If you have different pages, you need a corresponding folder within the content directory. For our blog posts, we will create a directory called \u0026ldquo;posts\u0026rdquo; in the content folder and copy our content from Obsidian into this folder.\nFor Windows use:\nrobocopy sourcepath destination path /mir For Mac/Linux use:\nrsync -av --delete \u0026#34;sourcepath\u0026#34; \u0026#34;destinationpath\u0026#34; Finally, to add images to these posts, we will use a script made by NetworkCheck. He explains it in his video, which I highly recommend watching as a follow-along. Make sure you have the correct paths to your own Obsidian Vault and Hugo site. These are Python scripts, so make sure you have Python installed to run them.\nFor Windows:\nimport os import re import shutil # Paths (using raw strings to handle Windows backslashes correctly) posts_dir = r\u0026#34;C:\\Users\\chuck\\Documents\\chuckblog\\content\\posts\u0026#34; attachments_dir = r\u0026#34;C:\\Users\\chuck\\Documents\\my_second_brain\\neotokos\\Attachments\u0026#34; static_images_dir = r\u0026#34;C:\\Users\\chuck\\Documents\\chuckblog\\static\\images\u0026#34; # Step 1: Process each markdown file in the posts directory for filename in os.listdir(posts_dir): if filename.endswith(\u0026#34;.md\u0026#34;): filepath = os.path.join(posts_dir, filename) with open(filepath, \u0026#34;r\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as file: content = file.read() # Step 2: Find all image links in the format ![Image Description](/images/Pasted%20image%20...%20.png) images = re.findall(r\u0026#39;\\[\\[([^]]*\\.png)\\]\\]\u0026#39;, content) # Step 3: Replace image links and ensure URLs are correctly formatted for image in images: # Prepare the Markdown-compatible link with %20 replacing spaces markdown_image = f\u0026#34;![Image Description](/images/{image.replace(\u0026#39; \u0026#39;, \u0026#39;%20\u0026#39;)})\u0026#34; content = content.replace(f\u0026#34;[[{image}]]\u0026#34;, markdown_image) # Step 4: Copy the image to the Hugo static/images directory if it exists image_source = os.path.join(attachments_dir, image) if os.path.exists(image_source): shutil.copy(image_source, static_images_dir) # Step 5: Write the updated content back to the markdown file with open(filepath, \u0026#34;w\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as file: file.write(content) print(\u0026#34;Markdown files processed and images copied successfully.\u0026#34;) And for Mac/Linux\nimport os import re import shutil # Paths posts_dir = \u0026#34;/Users/networkchuck/Documents/chuckblog/content/posts/\u0026#34; attachments_dir = \u0026#34;/Users/networkchuck/Documents/neotokos/Attachments/\u0026#34; static_images_dir = \u0026#34;/Users/networkchuck/Documents/chuckblog/static/images/\u0026#34; # Step 1: Process each markdown file in the posts directory for filename in os.listdir(posts_dir): if filename.endswith(\u0026#34;.md\u0026#34;): filepath = os.path.join(posts_dir, filename) with open(filepath, \u0026#34;r\u0026#34;) as file: content = file.read() # Step 2: Find all image links in the format ![Image Description](/images/Pasted%20image%20...%20.png) images = re.findall(r\u0026#39;\\[\\[([^]]*\\.png)\\]\\]\u0026#39;, content) # Step 3: Replace image links and ensure URLs are correctly formatted for image in images: # Prepare the Markdown-compatible link with %20 replacing spaces markdown_image = f\u0026#34;![Image Description](/images/{image.replace(\u0026#39; \u0026#39;, \u0026#39;%20\u0026#39;)})\u0026#34; content = content.replace(f\u0026#34;[[{image}]]\u0026#34;, markdown_image) # Step 4: Copy the image to the Hugo static/images directory if it exists image_source = os.path.join(attachments_dir, image) if os.path.exists(image_source): shutil.copy(image_source, static_images_dir) # Step 5: Write the updated content back to the markdown file with open(filepath, \u0026#34;w\u0026#34;) as file: file.write(content) print(\u0026#34;Markdown files processed and images copied successfully.\u0026#34;) Congratulations! After all these steps are done, we can run the Hugo server locally and hopefully see our formatted blog posts. This is all well and good; however, if we want anyone to be able to read these, we need to get them hosted on the internet. Luckily, GitHub has a free hosting service called \u0026ldquo;GitHub Pages.\nSetting up GitHub Pages # GitHub Pages is simple to set up. I will be following the official instructions to walk you through this (https://docs.github.com/en/pages/quickstart). First, make sure you have a GitHub account, create a repository called \u0026ldquo;your username\u0026rdquo;.github.io, and initialize the repository with a README. Next, go into the settings and navigate to the \u0026ldquo;Code and automation\u0026rdquo; section in the sidebar, then select the Pages section. From there, select Deploy from a branch under Source and choose your main branch under the branch setting. Now, any time we commit to this branch, it will update our site. Type your repository\u0026rsquo;s name in the URL bar to see if GitHub Pages has been set up correctly.\nHugo needs specific changes to work with GitHub pages (https://gohugo.io/host-and-deploy/host-on-github-pages/). In the site configuration, add the following to the end (for Blowfish its in config/_default/config.toml):\n[caches] [caches.images] dir = \u0026#39;:cacheDir/images\u0026#39; Now create a GitHub workflows directory and a configuration for deploying Hugo.\nmkdir -p .github/workflows touch .github/workflows/hugo.yaml Copy the following config into the hugo.yaml file we just created.\nname: Build and deploy on: push: branches: - main workflow_dispatch: permissions: contents: read pages: write id-token: write concurrency: group: pages cancel-in-progress: false defaults: run: shell: bash jobs: build: runs-on: ubuntu-latest env: DART_SASS_VERSION: 1.93.2 GO_VERSION: 1.25.1 HUGO_VERSION: 0.151.0 NODE_VERSION: 22.18.0 TZ: Europe/Oslo steps: - name: Checkout uses: actions/checkout@v5 with: submodules: recursive fetch-depth: 0 - name: Setup Go uses: actions/setup-go@v5 with: go-version: ${{ env.GO_VERSION }} cache: false - name: Setup Node.js uses: actions/setup-node@v4 with: node-version: ${{ env.NODE_VERSION }} - name: Setup Pages id: pages uses: actions/configure-pages@v5 - name: Create directory for user-specific executable files run: | mkdir -p \u0026#34;${HOME}/.local\u0026#34; - name: Install Dart Sass run: | curl -sLJO \u0026#34;https://github.com/sass/dart-sass/releases/download/${DART_SASS_VERSION}/dart-sass-${DART_SASS_VERSION}-linux-x64.tar.gz\u0026#34; tar -C \u0026#34;${HOME}/.local\u0026#34; -xf \u0026#34;dart-sass-${DART_SASS_VERSION}-linux-x64.tar.gz\u0026#34; rm \u0026#34;dart-sass-${DART_SASS_VERSION}-linux-x64.tar.gz\u0026#34; echo \u0026#34;${HOME}/.local/dart-sass\u0026#34; \u0026gt;\u0026gt; \u0026#34;${GITHUB_PATH}\u0026#34; - name: Install Hugo run: | curl -sLJO \u0026#34;https://github.com/gohugoio/hugo/releases/download/v${HUGO_VERSION}/hugo_extended_${HUGO_VERSION}_linux-amd64.tar.gz\u0026#34; mkdir \u0026#34;${HOME}/.local/hugo\u0026#34; tar -C \u0026#34;${HOME}/.local/hugo\u0026#34; -xf \u0026#34;hugo_extended_${HUGO_VERSION}_linux-amd64.tar.gz\u0026#34; rm \u0026#34;hugo_extended_${HUGO_VERSION}_linux-amd64.tar.gz\u0026#34; echo \u0026#34;${HOME}/.local/hugo\u0026#34; \u0026gt;\u0026gt; \u0026#34;${GITHUB_PATH}\u0026#34; - name: Verify installations run: | echo \u0026#34;Dart Sass: $(sass --version)\u0026#34; echo \u0026#34;Go: $(go version)\u0026#34; echo \u0026#34;Hugo: $(hugo version)\u0026#34; echo \u0026#34;Node.js: $(node --version)\u0026#34; - name: Install Node.js dependencies run: | [[ -f package-lock.json || -f npm-shrinkwrap.json ]] \u0026amp;\u0026amp; npm ci || true - name: Configure Git run: | git config core.quotepath false - name: Cache restore id: cache-restore uses: actions/cache/restore@v4 with: path: ${{ runner.temp }}/hugo_cache key: hugo-${{ github.run_id }} restore-keys: hugo- - name: Build the site run: | hugo \\ --gc \\ --minify \\ --baseURL \u0026#34;${{ steps.pages.outputs.base_url }}/\u0026#34; \\ --cacheDir \u0026#34;${{ runner.temp }}/hugo_cache\u0026#34; - name: Cache save id: cache-save uses: actions/cache/save@v4 with: path: ${{ runner.temp }}/hugo_cache key: ${{ steps.cache-restore.outputs.cache-primary-key }} - name: Upload artifact uses: actions/upload-pages-artifact@v3 with: path: ./public deploy: environment: name: github-pages url: ${{ steps.deployment.outputs.page_url }} runs-on: ubuntu-latest needs: build steps: - name: Deploy to GitHub Pages id: deployment uses: actions/deploy-pages@v4 Now we can commit all our changes to the repo and the site should automatically be generated. Remember to set our repository as the remote on the Hugo project.\nResults # After you commit to the repo, you should have a Hugo site that can be updated from our Obsidian Vault. This has been my first blog post written using this pipeline, and it makes a massive difference. Not only has this been fun to write, but it\u0026rsquo;s also been incredibly easy. Automatically seeing the formatted changes gives me more freedom in some design decisions and makes storing these blog posts much easier.\nI hope you\u0026rsquo;ve enjoyed setting this up and learnt a lot in th\n","date":"6 October 2025","externalUrl":null,"permalink":"/posts/making-a-tech-blog-using-hugo-and-obsidian/","section":"Posts","summary":"\u003cp\u003e{{\u0026lt; katex \u0026gt;}}\nFor a while, I\u0026rsquo;ve wanted to start a blog to share my ideas and try to articulate what I\u0026rsquo;ve learned. Before this iteration of the blog, I tried using a template YAML file within JavaScript to create blog posts. This approach was terrible; it was hard to see any syntax or even format it properly afterward. Sometimes, it\u0026rsquo;s better to use already developed tools and techniques. That\u0026rsquo;s where I found an amazing video by NetworkChuck about setting up a content pipeline using Obsidian to create the Markdown files for a blog, and using a templater such as Hugo to turn them into pretty webpages like the one you are reading now. In this post, I will go over the steps I took to create this blog, and hopefully inspire you to create one as it\u0026rsquo;s so easy \u003cdiv style=\"position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;\"\u003e\n      \u003ciframe allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share; fullscreen\" loading=\"eager\" referrerpolicy=\"strict-origin-when-cross-origin\" src=\"https://www.youtube.com/embed/dnE7c0ELEH8?autoplay=0\u0026amp;controls=1\u0026amp;end=0\u0026amp;loop=0\u0026amp;mute=0\u0026amp;start=0\" style=\"position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;\" title=\"YouTube video\"\u003e\u003c/iframe\u003e\n    \u003c/div\u003e\nE7c0ELEH8 \u0026gt;}}\u003c/p\u003e","title":"Making a Tech Blog using Hugo and Obsidian","type":"posts"},{"content":"","date":"6 October 2025","externalUrl":null,"permalink":"/tags/obsidian/","section":"Tags","summary":"","title":"Obsidian","type":"tags"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]